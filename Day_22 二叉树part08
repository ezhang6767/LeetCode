235. 二叉搜索树的最近公共祖先
https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/


#递归法（版本一）
class Solution:
    def traversal(self, cur, p, q):
        if cur is None:
            return cur

        if cur.val > p.val and cur.val > q.val:  # 如果当前节点的值比p和q的值都大，说明p和q都在当前节点的左子树中
            left = self.traversal(cur.left, p, q)  # 递归地在左子树中寻找最近公共祖先
            if left is not None:
                return left

        if cur.val < p.val and cur.val < q.val:  # 如果当前节点的值比p和q的值都小，说明p和q都在当前节点的右子树中
            right = self.traversal(cur.right, p, q)  # 递归地在右子树中寻找最近公共祖先
            if right is not None:
                return right

        return cur  # 如果当前节点的值既不比p和q的值都大，也不比p和q的值都小，说明当前节点就是最近公共祖先

    def lowestCommonAncestor(self, root, p, q):
        return self.traversal(root, p, q)
        
#迭代法        
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while root:
            if root.val > p.val and root.val > q.val:
                root = root.left
            elif root.val < p.val and root.val < q.val:
                root = root.right
            else:
                return root
        return None
