01背包

#代码随想录
def test_2_wei_bag_problem1(weight, value, bagweight):
    # 二维数组
    dp = [[0] * (bagweight + 1) for _ in range(len(weight))]

    # 初始化
    for j in range(weight[0], bagweight + 1):
        dp[0][j] = value[0]

    # weight数组的大小就是物品个数
    for i in range(1, len(weight)):  # 遍历物品
        for j in range(bagweight + 1):  # 遍历背包容量
            if j < weight[i]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])

    return dp[len(weight) - 1][bagweight]

if __name__ == "__main__":

    weight = [1, 3, 4]
    value = [15, 20, 30]
    bagweight = 4

    result = test_2_wei_bag_problem1(weight, value, bagweight)
    print(result)


#Chatgpt
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n)]

    for i in range(n):
        for w in range(capacity + 1):
            if weights[i] <= w:
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i]] + values[i])
            else:
                dp[i][w] = dp[i - 1][w]

    return dp

weights = [1, 3, 4]
values = [15, 20, 30]
capacity = 4

dp = knapsack(weights, values, capacity)

# 打印dp数组
for row in dp:
    print(row)







以下是根据背包最大重量为4，物品重量和价值如下的dp数组：

plaintext
Copy code
dp数组:
[0, 15, 15, 15, 15]
[0, 15, 15, 20, 35]
[0, 15, 15, 20, 35]


dp[1][3] = 20 的计算如下：

不放入物品1，只放入物品0。这意味着背包的剩余容量为3，总价值为 dp[0][3]。根据初始化的值，dp[0][3] = 15，因为背包容量为3时，只能放入物品0，其价值为15。

放入物品1。这意味着背包的剩余容量为0，总价值为 dp[0][0] 加上物品1的价值，即 dp[0][0] + value[1]。根据初始化的值，dp[0][0] = 0，因此总价值为 0 + 20 = 20。

因此，dp[1][3] 的值是这两种选择中的最大值，即 dp[1][3] = max(dp[0][3], dp[0][0] + value[1]) = max(15, 0 + 20) = 20。
