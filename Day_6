6 第三章 哈希表

哈希表理论基础：

当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。

但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法。


写法一（哈希表）：

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        record = [0] * 26
        for i in s:
            record[ord(i) - ord('a')] += 1      #并不需要记住字符a的ASCII，只要求出一个相对数值就可以了

        for i in t:
            record[ord(i) - ord('a')] -= 1

        for i in range(26):                     #record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
            if record[i] != 0:
                return False

        return True
        

写法二（defaultdict）:

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
    
        s_dict, t_dict = collections.defaultdict(int), collections.defaultdict(int)

        for i in s:
            s_dict[i] += 1

        for i in t:
            t_dict[i] += 1

        return s_dict == t_dict
        
写法三（Counter）：
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:

        s_count, t_count = collections.Counter(s), collections.Counter(t)   #使用Counter更方便
              
        #print(s_count,t_count)
        #s = "anagram", t = "nagaram"
        #Counter({'a': 3, 'n': 1, 'g': 1, 'r': 1, 'm': 1}) Counter({'a': 3, 'n': 1, 'g': 1, 'r': 1, 'm': 1})
        
        return s_count == t_count
        
349. 两个数组的交集
题意：给定两个数组，编写一个函数来计算它们的交集。
https://leetcode.cn/problems/intersection-of-two-arrays/

注意事项：
1. 输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序，可以使用哈希数据结构：unordered_set
2. 使用数组来做哈希的题目，是因为题目都限制了数值的大小。
3. 而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

#解法一：Hash Solution(dict)

class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        val_dict = {}               #相当于unordered_set
        ans = []                    #存放结果集
        for num in nums1:           #将nums1存放于哈希数组中，赋值为1
            val_dict[num] = 1

        for num in nums2:           #nums2和哈希数组作比较，当找到且值为1，存入结果集ans中
            if num in val_dict and val_dict[num] == 1:
                ans.append(num)     
                val_dict[num] = 0   #哈希数组值赋值为0防止重复查找

        return ans       

#解法二：List Solution

class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        i, j = 0, 0
        res = []
        while i < len(nums1) and j < len(nums2):
            if nums1[i] == nums2[j]:
                if not res or res[-1] != nums1[i]:      #去重; 或者用res = list(set(res))来去重
                    res.append(nums1[i])
                i += 1                                  #缩进所处的位置
                j += 1
            elif nums1[i] < nums2[j]:                   #因为是排序过的，i小了，i++
                i += 1
            else:
                j += 1                                  #j小了，j++
        return res


第202题. 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

https://leetcode.cn/problems/happy-number/description/

思路解析：
1. 判断sum是否重复出现是重点，需要哈希法。
2. 求和过程，需要对取数值各个位上的单数操作熟悉掌握。


class Solution:
    def isHappy(self, n: int) -> bool:
        def calculate_happy(num):               #定义函数生成快乐数
            sum_ = 0
            while num:
                sum_ += (num % 10) ** 2
                num = num // 10

            return sum_
        
        record = set()
        
        while True:
            n = calculate_happy(n)              #代入生成函数
            print(n)
            if n == 1:                          #三种情况：等于1（Ture），出现过（False），没出现过（加入数组）
                return True
            
            if n in record:
                return False

            else:
                record.add(n)                   #添加进入set数组进行去重, 需要用add而不是append


#集成解法（来自Chatgpt）
class Solution:
    def isHappy(self, n: int) -> bool:
        record = set()                                  #设定去重set集合
        while n not in record:                          #当n重复出现时，说明产生循环，停止遍历
            record.add(n)                       
            n = sum(int(i) ** 2 for i in str(n))        #int(i) ** 2 for i in int(n) 计算取值的简便写法
            print(n)
        return n == 1                                   #循环停止后判断n是否等于1
        
1. 两数之和
https://leetcode.cn/problems/two-sum/

注意事项：
1.使用enumerate，可以把一个可遍历的对象（如列表、字符串）组成一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。
2.使用 enumerate 可以直接得到数字的下标，而不需要再用 range 和 len 函数去计算，代码更简洁，容易理解。
3.for i, num in enumerate(nums):可以这么写

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        record = {}
        for i in range(len(nums)):      
            if (target - nums[i]) in record:        #遍历nums, 在record中寻找相匹配的值的下标（value）
                return i, record[target-nums[i]]

            record[nums[i]] = i                     #将值和下标，存入record中   
