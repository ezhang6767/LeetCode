6 第三章 哈希表

哈希表理论基础：

当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。

但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法。


写法一（哈希表）：

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        record = [0] * 26
        for i in s:
            record[ord(i) - ord('a')] += 1      #并不需要记住字符a的ASCII，只要求出一个相对数值就可以了

        for i in t:
            record[ord(i) - ord('a')] -= 1

        for i in range(26):                     #record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
            if record[i] != 0:
                return False

        return True
        

写法二（defaultdict）:

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
    
        s_dict, t_dict = collections.defaultdict(int), collections.defaultdict(int)

        for i in s:
            s_dict[i] += 1

        for i in t:
            t_dict[i] += 1

        return s_dict == t_dict
        
写法三（Counter）：
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:

        s_count, t_count = collections.Counter(s), collections.Counter(t)   #使用Counter更方便
              
        #print(s_count,t_count)
        #s = "anagram", t = "nagaram"
        #Counter({'a': 3, 'n': 1, 'g': 1, 'r': 1, 'm': 1}) Counter({'a': 3, 'n': 1, 'g': 1, 'r': 1, 'm': 1})
        
        return s_count == t_count
        
349. 两个数组的交集
题意：给定两个数组，编写一个函数来计算它们的交集。
https://leetcode.cn/problems/intersection-of-two-arrays/

注意事项：
1. 输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序，可以使用哈希数据结构：unordered_set
2. 使用数组来做哈希的题目，是因为题目都限制了数值的大小。
3. 而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

#解法一：Hash Solution(dict)

class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        val_dict = {}               #相当于unordered_set
        ans = []                    #存放结果集
        for num in nums1:           #将nums1存放于哈希数组中，赋值为1
            val_dict[num] = 1

        for num in nums2:           #nums2和哈希数组作比较，当找到且值为1，存入结果集ans中
            if num in val_dict and val_dict[num] == 1:
                ans.append(num)     
                val_dict[num] = 0   #哈希数组值赋值为0防止重复查找

        return ans       

#解法二：List Solution

class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()
        i, j = 0, 0
        res = []
        while i < len(nums1) and j < len(nums2):
            if nums1[i] == nums2[j]:
                if not res or res[-1] != nums1[i]:      #去重; 或者用res = list(set(res))来去重
                    res.append(nums1[i])
                i += 1                                  #缩进所处的位置
                j += 1
            elif nums1[i] < nums2[j]:                   #因为是排序过的，i小了，i++
                i += 1
            else:
                j += 1                                  #j小了，j++
        return res
