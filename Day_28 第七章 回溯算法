93.复原IP地址  
https://leetcode.cn/problems/restore-ip-addresses/

class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        result = []
        self.backtracking(s, 0, 0, "", result)  # 调用回溯函数进行IP地址恢复
        return result

    def backtracking(self, s, start_index, point_num, current, result):
        if point_num == 3:  # 逗点数量为3时，分隔结束
            if self.is_valid(s, start_index, len(s) - 1):  # 判断第四段子字符串是否合法
                current += s[start_index:]  # 添加最后一段子字符串
                result.append(current)  # 将恢复的IP地址加入结果列表
            return

        for i in range(start_index, len(s)):
            if self.is_valid(s, start_index, i):  # 判断 [start_index, i] 这个区间的子串是否合法
                sub = s[start_index:i + 1]  # 获取子串 [start_index, i]
                current_sub_dot = current + sub + '.'  # 当前的IP地址段
                self.backtracking(s, i + 1, point_num + 1, current_sub_dot, result)  # 递归调用，更新start_index和point_num
            else:
                break  # 子串不合法，直接结束循环，进入下一个起始位置

    def is_valid(self, s, start, end):
        if start > end:
            return False
        if s[start] == '0' and start != end:  # 0开头的数字不合法，除非是单个0
            return False
        num = 0
        for i in range(start, end + 1):
            if not s[i].isdigit():  # 遇到非数字字符不合法
                return False
            num = num * 10 + int(s[i])  # 计算数字大小
            if num > 255:  # 如果大于255了不合法
                return False
        return True

#每次递归调用中，打印出 point_num、current、sub、current + sub + '.' 的值。
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        result = []
        self.backtracking(s, 0, 0, "", result)
        return result

    def backtracking(self, s, start_index, point_num, current, result):
        if point_num == 3:
            if self.is_valid(s, start_index, len(s) - 1):
                current += s[start_index:]
                result.append(current)
                print("Found valid IP address:", current)
            return

        for i in range(start_index, len(s)):
            if self.is_valid(s, start_index, i):
                sub = s[start_index:i + 1]
                print("point_num:", point_num)
                print("current:", current)
                print("sub:", sub)
                current_sub_dot = current + sub + '.'
                print("current + sub + '.':", current_sub_dot)
                self.backtracking(s, i + 1, point_num + 1, current_sub_dot, result)
                print("Backtracking to previous state...")
            else:
                break

    def is_valid(self, s, start, end):
        if start > end:
            return False
        if s[start] == '0' and start != end:
            return False
        num = 0
        for i in range(start, end + 1):
            if not s[i].isdigit():
                return False
            num = num * 10 + int(s[i])
            if num > 255:
                return False
        return True

