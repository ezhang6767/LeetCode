110.平衡二叉树 （优先掌握递归）
https://leetcode.cn/problems/balanced-binary-tree/

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        if self.get_height(root) != -1:
            return True
        else:
            return False

    def get_height(self, root: TreeNode) -> int:
        # Base Case
        if not root:
            return 0
        # 左
        if (left_height := self.get_height(root.left)) == -1:
            return -1
        # 右
        if (right_height := self.get_height(root.right)) == -1:
            return -1
        # 中
        if abs(left_height - right_height) > 1:
            return -1
        else:
            return 1 + max(left_height, right_height)


海象操作符 := walrus operator

相当于：
        left_height = self.get_height(root.left)
        if left_height == -1:
           return -1

使用细节：

在这两个条件语句中，使用了不同的括号位置，从而导致了不同的结果。

if (left_height := self.get_height(root.left)) == -1:：

在这个条件语句中，使用了括号将赋值表达式 (left_height := self.get_height(root.left)) 括起来。
这意味着先执行赋值操作 (left_height := self.get_height(root.left))，将 self.get_height(root.left) 的结果赋值给 left_height。
然后，比较 left_height 和 -1 的值是否相等。
如果相等，执行相应的操作。

if left_height := self.get_height(root.left) == -1:：

在这个条件语句中，没有使用括号。
根据Python的运算符优先级，比较操作符 == 的优先级高于赋值操作符 :=。
因此，先执行比较操作 self.get_height(root.left) == -1，得到一个布尔值。
然后，将这个布尔值赋值给 left_height。
最后，根据 left_height 的值执行相应的操作。
因此，这两种写法的区别在于赋值操作和比较操作的先后顺序。
第一种写法先进行赋值，再进行比较；
第二种写法先进行比较，再进行赋值。这可能会导致不同的结果。


257. 二叉树的所有路径

https://leetcode.cn/problems/binary-tree-paths/

递归法+回溯
class Solution:
    def traversal(self, cur, path, result):
        path.append(cur.val)  # 将当前节点的值添加到路径中（中）
        if not cur.left and not cur.right:  # 到达叶子节点
            sPath = '->'.join(map(str, path))  # 将路径中的节点值转换为字符串，并用 '->' 连接起来
            result.append(sPath)  # 将完整的路径添加到结果列表中
            return
        if cur.left:  # 处理左子节点（左）
            self.traversal(cur.left, path, result)  # 递归调用，传入左子节点和当前路径
            path.pop()  # 回溯，移除已经处理完的左子节点
        if cur.right:  # 处理右子节点（右）
            self.traversal(cur.right, path, result)  # 递归调用，传入右子节点和当前路径
            path.pop()  # 回溯，移除已经处理完的右子节点

    def binaryTreePaths(self, root):
        result = []  # 存储最终结果的列表
        path = []  # 当前路径的列表
        if not root:
            return result
        self.traversal(root, path, result)  # 从根节点开始进行递归遍历
        return result  # 返回结果列表
