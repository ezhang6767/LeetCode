#332.重新安排行程
#used数组法
class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        tickets.sort()    # 先排序，这样一旦找到第一个可行路径，一定是字母排序最小的
        used = [0] * len(tickets)
        path = ['JFK']
        results = []
        self.backtracking(tickets, used, path, 'JFK', results)
        return results[0]

    """这里给出了主函数findItinerary，它接受一个字符串二维列表tickets作为输入，表示航班的起始和终止机场。
    tickets是按照字母顺序排序的。used是一个记录航班是否已经使用的数组，
    path用于记录当前行程，results是存储所有合法行程的列表。这个函数的目标是找到一个合法行程，并返回其中一个。"""

    def backtracking(self, tickets, used, path, cur, results):
        if len(path) == len(tickets) + 1:    # 终止条件：路径长度等于机票数量+1
            results.append(path[:])          # 将当前路径添加到结果列表
            return True

    """这是回溯函数backtracking的定义，它会递归地搜索所有可能的行程。
    当path的长度等于tickets长度加1时，说明找到了一个合法的行程，
    将其拷贝加入results，并返回True表示找到了合法行程。"""

        for i, ticket in enumerate(tickets):         # 遍历机票列表
            if ticket[0] == cur and used[i] == 0:    # 找到起始机场为cur且未使用过的机票
                used[i] = 1                          # 标记该机票为已使用
                path.append(ticket[1])               # 将到达机场ticket[1]添加到路径中
                state = self.backtracking(tickets, used, path, ticket[1], results)   # 递归搜索
                path.pop()                           # 回溯，移除最后添加的到达机场
                used[i] = 0                          # 标记该机票为未使用
                if state:
                    return True                      # 只要找到一个可行路径就返回，不继续搜索

      """这是回溯函数的具体实现。它遍历tickets中的每个航班，并检查是否满足以下条件：
      
      起始机场与当前机场相同 (ticket[0] == cur)。
      当前航班尚未被使用 (used[i] == 0)。
      如果满足这两个条件，表示可以选择当前航班，于是进行以下操作：
      
      将当前航班标记为已使用 (used[i] = 1)。
      将当前航班的终点机场加入行程路径 (path.append(ticket[1]))。
      递归调用backtracking函数，从当前终点机场出发继续搜索下一个航班。
      回溯，即撤销之前加入的终点机场，为下一次搜索做准备 (path.pop())。
      将当前航班标记为未使用 (used[i] = 0)。
      在递归调用中，如果找到了一个合法行程（self.backtracking(tickets, used, path, ticket[1], results)返回True），
      则当前层的递归也会返回True，直接结束搜索。
      
      整体上，这段代码利用回溯算法进行了深度优先搜索，尝试从每个起始机场出发找到一个合法的行程，
      并将其存储在results中。一旦找到一个合法行程，即完成任务，函数返回结果。
      由于题目中保证一定存在至少一个合法行程，因此直接返回results[0]即可得到一个合法行程。"""

#回溯 使用字典
from collections import defaultdict

class Solution:
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        targets = defaultdict(list)  # 构建机场字典
        for ticket in tickets:
            targets[ticket[0]].append(ticket[1])
        for airport in targets:
            targets[airport].sort()  # 对目的地列表进行排序

        path = ["JFK"]  # 起始机场为"JFK"
        self.backtracking(targets, path, len(tickets))
        return path

    def backtracking(self, targets, path, ticketNum):
        if len(path) == ticketNum + 1:
            return True  # 找到有效行程

        airport = path[-1]  # 当前机场
        destinations = targets[airport]  # 当前机场可以到达的目的地列表
        for i, dest in enumerate(destinations):
            targets[airport].pop(i)  # 标记已使用的机票
            path.append(dest)  # 添加目的地到路径
            if self.backtracking(targets, path, ticketNum):
                return True  # 找到有效行程
            targets[airport].insert(i, dest)  # 回溯，恢复机票
            path.pop()  # 移除目的地
        return False  # 没有找到有效行程

#回溯 使用字典 逆序

from collections import defaultdict

class Solution:
    def findItinerary(self, tickets):
        targets = defaultdict(list)  # 创建默认字典，用于存储机场映射关系
        for ticket in tickets:
            targets[ticket[0]].append(ticket[1])  # 将机票输入到字典中
        
        for key in targets:
            targets[key].sort(reverse=True)  # 对到达机场列表进行字母逆序排序
        
        result = []
        self.backtracking("JFK", targets, result)  # 调用回溯函数开始搜索路径
        return result[::-1]  # 返回逆序的行程路径
    
    def backtracking(self, airport, targets, result):
        while targets[airport]:  # 当机场还有可到达的机场时
            next_airport = targets[airport].pop()  # 弹出下一个机场
            self.backtracking(next_airport, targets, result)  # 递归调用回溯函数进行深度优先搜索
        result.append(airport)  # 将当前机场添加到行程路径中

为什么这种 DFS 逆序可以获得正确答案，其实和有向图的欧拉路径求法有关，
对原理更加详细剖析见题解：https://leetcode.cn/problems/reconstruct-itinerary/solutions/8209/javadfsjie-fa-by-pwrliang/
