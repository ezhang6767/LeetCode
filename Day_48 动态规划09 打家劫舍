198.打家劫舍
https://leetcode.cn/problems/house-robber/

#1 dp[i] = 第i个房间能偷到的最大金额
#2 当前房间的状态有两种：1， 偷： dp[i-2]+nums[i] 2, 不偷: dp[i-1]
#3 初始状态：由于dp[i]由dp[i-1], dp[i-2] 推导而出 所以需要初始化dp[0]=nums[0], dp[1]=max(dp[0], dp[1]).
#4 遍历顺序：从小至大 
#5 打印dp数组

1维DP

class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0:  # 如果没有房屋，返回0
            return 0
        if len(nums) == 1:  # 如果只有一个房屋，返回其金额
            return nums[0]

        # 创建一个动态规划数组，用于存储最大金额
        dp = [0] * len(nums)
        dp[0] = nums[0]  # 将dp的第一个元素设置为第一个房屋的金额
        dp[1] = max(nums[0], nums[1])  # 将dp的第二个元素设置为第一二个房屋中的金额较大者

        # 遍历剩余的房屋
        for i in range(2, len(nums)):
            # 对于每个房屋，选择抢劫当前房屋和抢劫前一个房屋的最大金额
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])

        return dp[-1]  # 返回最后一个房屋中可抢劫的最大金额
2维DP

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:  # 如果没有房屋，返回0
            return 0

        n = len(nums)
        dp = [[0, 0] for _ in range(n)]  # 创建二维动态规划数组，dp[i][0]表示不抢劫第i个房屋的最大金额，dp[i][1]表示抢劫第i个房屋的最大金额

        dp[0][1] = nums[0]  # 抢劫第一个房屋的最大金额为第一个房屋的金额

        for i in range(1, n):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1])  # 不抢劫第i个房屋，最大金额为前一个房屋抢劫和不抢劫的最大值
            dp[i][1] = dp[i-1][0] + nums[i]  # 抢劫第i个房屋，最大金额为前一个房屋不抢劫的最大金额加上当前房屋的金额

        return max(dp[n-1][0], dp[n-1][1])  # 返回最后一个房屋中可抢劫的最大金额

优化版

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:  # 如果没有房屋，返回0
            return 0

        prev_max = 0  # 上一个房屋的最大金额
        curr_max = 0  # 当前房屋的最大金额

        for num in nums:
            temp = curr_max  # 临时变量保存当前房屋的最大金额
            curr_max = max(prev_max + num, curr_max)  # 更新当前房屋的最大金额
            prev_max = temp  # 更新上一个房屋的最大金额

        return curr_max  # 返回最后一个房屋中可抢劫的最大金额

213. 打家劫舍 II
https://leetcode.cn/problems/house-robber-ii/description/

class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        if len(nums) == 1:
            return nums[0]

        result1 = self.robRange(nums, 0, len(nums)-2)   #情况2
        result2 = self.robRange(nums, 1, len(nums)-1)   #情况3

        return max(result1, result2)
    #198 打家劫舍
    def robRange(self, nums:list[int], start: int, end: int) -> int:
        if end == start:            #len == 1
            return nums[start]

        prev_max = nums[start]      #dp[0] = nums[0]
        cur_max = max(nums[start], nums[start+1])   #dp[1] = max(nums[0], nums[1])

        for i in range(start+2, end+1):
            temp = cur_max  # 临时变量保存当前房屋的最大金额
            cur_max = max(prev_max+nums[i], cur_max)    # 更新当前房屋的最大金额
            prev_max = temp # 更新上一个房屋的最大金额

        return cur_max


